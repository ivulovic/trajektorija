<!doctype html> <html lang=sr> <head> <meta charset=utf-8> <meta content=#333333 name=theme-color> <meta content="width=device-width,initial-scale=1" name=viewport> <title>Трајекторија</title> <meta content="трајекторија, блог, на српском, јаваскрипт, програмирање, србија" name=keywords> <meta content=Трајекторија name=title> <meta content=Трајекторија property=og:title> <meta content=Трајекторија property=twitter:title> <meta content="Трајекторија се бави темама из света програмирања. Циљ је скроман допринос српској заједници програмера." name=description> <meta content="Трајекторија се бави темама из света програмирања. Циљ је скроман допринос српској заједници програмера." property=og:description> <meta content="Трајекторија се бави темама из света програмирања. Циљ је скроман допринос српској заједници програмера." property=twitter:description> <meta content=https://trajektorija.com/logo_large.png property=og:image> <meta content=https://trajektorija.com/logo_large.png property=twitter:image> <meta content="Логотип сајта Трајекторија" property=og:image:alt> <meta content="Логотип сајта Трајекторија" property=twitter:image:alt> <meta content=https://trajektorija.com property=og:url> <meta content=website property=og:type> <meta content=summary_large_image property=twitter:card> <link href=https://fonts.gstatic.com rel=preconnect> <link href="https://fonts.googleapis.com/css2?family=Fira+Sans:wght@400;500&family=Roboto+Condensed:wght@400;500&display=swap" rel=stylesheet> <base href=/ > <link href=global.css rel=stylesheet> <link href=manifest.json rel=manifest crossorigin=use-credentials> <link href=favicon.png rel=icon type=image/png> <script>__SAPPER__={baseUrl:"",preloaded:[void 0,(function(a,b){return {post:{title:a,description:b,html:"\n\u003Cp\u003E\n  Још одавно се појавила потреба да се велике количине података обрађују на што ефективнији начин. \n  Можда најбољи пример су управо Ексел табеле где имамо на хиљаде записа који су међусобно повезани, \n  а када дође до промене мењају се само поља која су међусобно зависна, без беспотребног проверавања свих осталих.\n  Управо о овоме се ради и у реактивном програмирању.\n\u003C\u002Fp\u003E\n\n\u003Cp\u003E\n  Хајде да погледамо ово парче кода:\n\u003C\u002Fp\u003E\n\n\u003Ccode\u003E\n\u003Cpre\u003E\nvar a = 1;\nvar b = 2;\nvar c = a + b;\na = 10;\nconsole.log(c); \u002F\u002F 3\n\u003C\u002Fpre\u003E\n\u003C\u002Fcode\u003E\n\n\u003Cp\u003E\n  Зашто није исписало \u003Cb\u003E12\u003C\u002Fb\u003E? Зато што \u003Cb\u003E=\u003C\u002Fb\u003E није оператор реактивног додељивања.\n\u003C\u002Fp\u003E\n\n\u003Cp\u003E\n  Дакле треба нам неки нови оператор који ће да изврши такав начин доделе вредности. \n  У Јаваскрипту такав оператор не постоји и ово што ћемо сада видети би довело до синтаксне грешке.\n\u003C\u002Fp\u003E\n\n\u003Cp\u003E\n  Замислимо да постоји оператор \u003Cb\u003E$=\u003C\u002Fb\u003E - оператор реактивног додељивања.\n\u003C\u002Fp\u003E\n\n\u003Ccode\u003E\n\u003Cpre\u003E\nvar a = 1;\nvar b = 2;\nvar c $= a + b;\na = 10;\nconsole.log(c); \u002F\u002F 12\n\u003C\u002Fpre\u003E\n\u003C\u002Fcode\u003E\n\n\u003Cp\u003E\n  Суштина реактивног програмирања је у протоку података и праћењу вредности које пролазе кроз апликацију. Када се промени податак апликација би требало да одреагује.\n\u003C\u002Fp\u003E\n\n\u003Cp\u003E\n  И ту долазимо до Риекта, он је стварно направио велике промене у свету веб програмирања. Користили га људи или не, он је веома утицао на много других језика шаблонима које користи.\n  Још од 2013, откако је изашао, критиковао је многе постојеће библиотеке које су тада биле веома популарне и указивао на проблеме који постоје, а којих је ретко ко био свестан. \n  Баш та критика је довела до многих расправа, а потом промена и модернизације Јаваскипта као језика.\n\u003C\u002Fp\u003E\n\n\u003Cp\u003E\n  Вратимо се на тему да видимо како Риект ради.\n\u003C\u002Fp\u003E\n\n\u003Ccode\u003E\n\u003Cpre\u003E\nfunction App(){\n  const [count, setCount] = useState();\n  const [name, setName] = useState(\"world\");\n\n  const handleClick = () =\u003E {\n    setCount(count+1);\n  }\n\n  const handleInput = (e) =\u003E {\n    setName(e.target.value);\n  }\n  \n  return (\n    &lt;div className=\"app\"&gt;\n      &lt;h1&gt;Hello {name}&lt;\u002Fh1&gt;\n      &lt;input value={name} onInput={handleInput} \u002F&gt;\n\n      &lt;button onClick={handleClick}&gt;\n        Clicks: {count}\n      &lt;\u002Fbutton&gt;\n    &lt;\u002Fdiv&gt;\n  )\n}\n\u003C\u002Fpre\u003E\n\u003C\u002Fcode\u003E\n\n\u003Cp\u003E\n  Ово је једноставна апликација која се састоји од једне компоненте. \n  Компонента има своје локално стање које се састоји од поља \u003Cb\u003Ecount\u003C\u002Fb\u003E и \u003Cb\u003Ename\u003C\u002Fb\u003E. \n  Такође има и две функције које мењају вредности ова два поља, односно мењају локално стање компоненте.\n  На крају враћамо парче виртуелног ДОМ-а.\n\u003C\u002Fp\u003E\n\n\u003Cp\u003E \n  Сваки пут када се стање у компоненти промени, виртуелни ДОМ се поново генерише, а Риектов посао је да усклади оно што је било раније са оним што је дошло касније. \n  Тај процес је познат и као \u003Cb\u003Ereconciliation\u003C\u002Fb\u003E.\n\u003C\u002Fp\u003E\n\n\u003Cp\u003E\n  Дакле хајде да видимо како овај процес усклађивања изгледа у случају када корисник кликне на дугме и повећа вредност поља \u003Cb\u003Ecount\u003C\u002Fb\u003E:\n\u003C\u002Fp\u003E\n\n\u003Ccode\u003E\n\u003Cpre\u003E\nelement: div\n  className: app\n  children:\n    element: h1\n      children:\n        text: Hello world\n    element: input\n      value: world\n    element: button\n      text: Clicks: 1\n\u003C\u002Fpre\u003E\n\u003C\u002Fcode\u003E\n\n\u003Cp\u003E\n  Крећемо са врха:\n\u003C\u002Fp\u003E\n\u003Cul\u003E\n  \u003Cli\u003EЕлемент \u003Cb\u003Ediv\u003C\u002Fb\u003E је остао непромењен - задржавамо га\u003C\u002Fli\u003E\n  \u003Cli\u003EЕлемент \u003Cb\u003Ediv\u003C\u002Fb\u003E садржи атрибут \u003Cb\u003EclassName\u003C\u002Fb\u003E који је остао непромењен - задржавамо га\u003C\u002Fli\u003E\n  \u003Cli\u003EПрво дете елемента  \u003Cb\u003Ediv\u003C\u002Fb\u003E је елемент \u003Cb\u003Eh1\u003C\u002Fb\u003E који је остао непромењен - задржавамо га\u003C\u002Fli\u003E\n  \u003Cli\u003EЕлемент \u003Cb\u003Eh1\u003C\u002Fb\u003E у себи има текст који се није мењао - задржавамо га\u003C\u002Fli\u003E\n  \u003Cli\u003EДруго дете  елемента  \u003Cb\u003Ediv\u003C\u002Fb\u003E  је \u003Cb\u003Einput\u003C\u002Fb\u003E и он је остао непромењен - задржавамо га \u003C\u002Fli\u003E\n  \u003Cli\u003EЕлемент \u003Cb\u003Einput\u003C\u002Fb\u003E  има вредност која се није мењала  - задржавамо га\u003C\u002Fli\u003E\n  \u003Cli\u003EНаилазимо на треће дете  елемента  \u003Cb\u003Ediv\u003C\u002Fb\u003E, на елемент \u003Cb\u003Ebutton\u003C\u002Fb\u003E, који је остао непромењен  - задржавамо га\u003C\u002Fli\u003E\n  \u003Cli\u003EЕлементу \u003Cb\u003Ebutton\u003C\u002Fb\u003E се променио текст са 0 на 1 - извршавамо промену на ДОМ-у\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\n\u003Cp\u003E\n  Толико посла да би се текст на дугмету са 0 променио на 1.\n\u003C\u002Fp\u003E\n\n\u003Cp\u003E\n  Још горе од овога је сама помисао да се све ове функције поново праве испочетка сваки пут када се промени стање у компоненти. \n  Ово је само мали пример, али ако замислимо како би се то одразило на велике пројекте где има много више угњеждених компоненти, то би представљало много већи проблем.\n  Из личног искуства сам се уверио да људи јако ретко користе ове помоћне методе, \n  па тако можемо да наиђемо на чест случај где радимо филтрирање великих низова изнова и изнова не помишљајући на \u003Cb\u003EuseMemo\u003C\u002Fb\u003E или неки други начин.\n  Ако идемо овим путем проблем ће се појавити врло брзо, тако да кроз само неколико месеци аљкавог писања кода можемо да дођемо до тога да апликација постане значајно спорија.\n\u003C\u002Fp\u003E\n\n\u003Cp\u003E\n  У циљу да спречимо непотребно поновно исцртавање и проверавање, главни тим нам је пружио неколико функција:\n\u003C\u002Fp\u003E\n\u003Cul\u003E\n  \u003Cli\u003EshouldComponentUpdate\u003C\u002Fli\u003E\n  \u003Cli\u003EReact.PureComponent\u003C\u002Fli\u003E\n  \u003Cli\u003EuseMemo\u003C\u002Fli\u003E\n  \u003Cli\u003EuseCallback\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\n\u003Cp\u003E\n  Ово нам говори да су и они сами свесни да је потребно да се ради на додатним оптимизацијама, да је читав процес поновног исцртавања компоненти веома скуп и да овде уопште нема реактивности. \n\u003C\u002Fp\u003E\n\u003Cp\u003E\n  А да ли је довољно брз да задовољи захтеве већине? \n  То сигурно да.\n\u003C\u002Fp\u003E\n",slug:"ispitivanje-reaktivnosti-u-reactu",categories:[{id:"reaktivnost",label:"Реактивност"},{id:"react",label:"Риект"}],date:1620071150231,metadata:{title:a,description:b,keywords:"Реактивност, Риект",url:"https:\u002F\u002Ftrajektorija.com\u002Fispitivanje-reaktivnosti-u-reactu",thumb:"https:\u002F\u002Ftrajektorija.com\u002Fimages\u002Fposts\u002Fispitivanje-reaktivnosti-u-reactu.png",thumbAlt:"Логотип сајта Трајекторија"}}}}("Испитивање реактивности у Риекту","О реактивности и како се Риект носи с тим"))]};if('serviceWorker' in navigator)navigator.serviceWorker.register('/service-worker.js');(function(){try{eval("async function x(){}");var main="/client/client.ab6114d9.js"}catch(e){main="/client/legacy/client.a30cb9ef.js"};var s=document.createElement("script");try{new Function("if(0)import('')")();s.src=main;s.type="module";s.crossOrigin="use-credentials";}catch(e){s.src="/client/shimport@2.0.4.js";s.setAttribute("data-main",main);}document.head.appendChild(s);}());</script> <link href=client/client-9de7cf7e.css rel=stylesheet><link href=client/[slug]-da9fd523.css rel=stylesheet> <title>Испитивање реактивности у Риекту | Трајекторија</title><meta content="Реактивност, Риект" data-svelte=svelte-jnjsyk name=keywords><meta content="Испитивање реактивности у Риекту" data-svelte=svelte-jnjsyk name=title><meta content="Испитивање реактивности у Риекту" property=og:title data-svelte=svelte-jnjsyk><meta content="Испитивање реактивности у Риекту" property=twitter:title data-svelte=svelte-jnjsyk><meta content="О реактивности и како се Риект носи с тим" data-svelte=svelte-jnjsyk name=description><meta content="О реактивности и како се Риект носи с тим" property=og:description data-svelte=svelte-jnjsyk><meta content="О реактивности и како се Риект носи с тим" property=twitter:description data-svelte=svelte-jnjsyk><meta content=https://trajektorija.com/images/posts/ispitivanje-reaktivnosti-u-reactu.png property=og:image data-svelte=svelte-jnjsyk><meta content=https://trajektorija.com/images/posts/ispitivanje-reaktivnosti-u-reactu.png property=twitter:image data-svelte=svelte-jnjsyk><meta content="Логотип сајта Трајекторија" property=og:image:alt data-svelte=svelte-jnjsyk><meta content="Логотип сајта Трајекторија" property=twitter:image:alt data-svelte=svelte-jnjsyk><meta content=https://trajektorija.com/ispitivanje-reaktivnosti-u-reactu property=og:url data-svelte=svelte-jnjsyk><meta content=article property=og:type data-svelte=svelte-jnjsyk><meta content=summary_large_image property=twitter:card data-svelte=svelte-jnjsyk> <link href=/client/client.ab6114d9.js rel=modulepreload as=script crossorigin=use-credentials><link href=/client/client-9de7cf7e.css rel=preload as=style><link href=/client/[slug].ecece195.js rel=modulepreload as=script crossorigin=use-credentials><link href=/client/index.a28fdc80.js rel=modulepreload as=script crossorigin=use-credentials><link href=/client/inject_styles.5607aec6.js rel=modulepreload as=script crossorigin=use-credentials><link href=/client/[slug]-da9fd523.css rel=preload as=style></head> <body> <div id=sapper> <div class="svelte-1qbgn1e nav"><a class=svelte-1qbgn1e href=/ ><div class="svelte-1qbgn1e center-logo"><h1 class=svelte-1qbgn1e>Трајекторија</h1></div></a></div> <main class=svelte-1eviz8r> <div><h1 class=svelte-1rblvs9>Испитивање реактивности у Риекту</h1> <div class="svelte-1rblvs9 content"> <p> Још одавно се појавила потреба да се велике количине података обрађују на што ефективнији начин. Можда најбољи пример су управо Ексел табеле где имамо на хиљаде записа који су међусобно повезани, а када дође до промене мењају се само поља која су међусобно зависна, без беспотребног проверавања свих осталих. Управо о овоме се ради и у реактивном програмирању. </p> <p> Хајде да погледамо ово парче кода: </p> <code> <pre>
var a = 1;
var b = 2;
var c = a + b;
a = 10;
console.log(c); // 3
</pre> </code> <p> Зашто није исписало <b>12</b>? Зато што <b>=</b> није оператор реактивног додељивања. </p> <p> Дакле треба нам неки нови оператор који ће да изврши такав начин доделе вредности. У Јаваскрипту такав оператор не постоји и ово што ћемо сада видети би довело до синтаксне грешке. </p> <p> Замислимо да постоји оператор <b>$=</b> - оператор реактивног додељивања. </p> <code> <pre>
var a = 1;
var b = 2;
var c $= a + b;
a = 10;
console.log(c); // 12
</pre> </code> <p> Суштина реактивног програмирања је у протоку података и праћењу вредности које пролазе кроз апликацију. Када се промени податак апликација би требало да одреагује. </p> <p> И ту долазимо до Риекта, он је стварно направио велике промене у свету веб програмирања. Користили га људи или не, он је веома утицао на много других језика шаблонима које користи. Још од 2013, откако је изашао, критиковао је многе постојеће библиотеке које су тада биле веома популарне и указивао на проблеме који постоје, а којих је ретко ко био свестан. Баш та критика је довела до многих расправа, а потом промена и модернизације Јаваскипта као језика. </p> <p> Вратимо се на тему да видимо како Риект ради. </p> <code> <pre>
function App(){
  const [count, setCount] = useState();
  const [name, setName] = useState("world");

  const handleClick = () => {
    setCount(count+1);
  }

  const handleInput = (e) => {
    setName(e.target.value);
  }
  
  return (
    &lt;div className="app">
      &lt;h1>Hello {name}&lt;/h1>
      &lt;input value={name} onInput={handleInput} />

      &lt;button onClick={handleClick}>
        Clicks: {count}
      &lt;/button>
    &lt;/div>
  )
}
</pre> </code> <p> Ово је једноставна апликација која се састоји од једне компоненте. Компонента има своје локално стање које се састоји од поља <b>count</b> и <b>name</b>. Такође има и две функције које мењају вредности ова два поља, односно мењају локално стање компоненте. На крају враћамо парче виртуелног ДОМ-а. </p> <p> Сваки пут када се стање у компоненти промени, виртуелни ДОМ се поново генерише, а Риектов посао је да усклади оно што је било раније са оним што је дошло касније. Тај процес је познат и као <b>reconciliation</b>. </p> <p> Дакле хајде да видимо како овај процес усклађивања изгледа у случају када корисник кликне на дугме и повећа вредност поља <b>count</b>: </p> <code> <pre>
element: div
  className: app
  children:
    element: h1
      children:
        text: Hello world
    element: input
      value: world
    element: button
      text: Clicks: 1
</pre> </code> <p> Крећемо са врха: </p> <ul> <li>Елемент <b>div</b> је остао непромењен - задржавамо га</li> <li>Елемент <b>div</b> садржи атрибут <b>className</b> који је остао непромењен - задржавамо га</li> <li>Прво дете елемента <b>div</b> је елемент <b>h1</b> који је остао непромењен - задржавамо га</li> <li>Елемент <b>h1</b> у себи има текст који се није мењао - задржавамо га</li> <li>Друго дете елемента <b>div</b> је <b>input</b> и он је остао непромењен - задржавамо га </li> <li>Елемент <b>input</b> има вредност која се није мењала - задржавамо га</li> <li>Наилазимо на треће дете елемента <b>div</b>, на елемент <b>button</b>, који је остао непромењен - задржавамо га</li> <li>Елементу <b>button</b> се променио текст са 0 на 1 - извршавамо промену на ДОМ-у</li> </ul> <p> Толико посла да би се текст на дугмету са 0 променио на 1. </p> <p> Још горе од овога је сама помисао да се све ове функције поново праве испочетка сваки пут када се промени стање у компоненти. Ово је само мали пример, али ако замислимо како би се то одразило на велике пројекте где има много више угњеждених компоненти, то би представљало много већи проблем. Из личног искуства сам се уверио да људи јако ретко користе ове помоћне методе, па тако можемо да наиђемо на чест случај где радимо филтрирање великих низова изнова и изнова не помишљајући на <b>useMemo</b> или неки други начин. Ако идемо овим путем проблем ће се појавити врло брзо, тако да кроз само неколико месеци аљкавог писања кода можемо да дођемо до тога да апликација постане значајно спорија. </p> <p> У циљу да спречимо непотребно поновно исцртавање и проверавање, главни тим нам је пружио неколико функција: </p> <ul> <li>shouldComponentUpdate</li> <li>React.PureComponent</li> <li>useMemo</li> <li>useCallback</li> </ul> <p> Ово нам говори да су и они сами свесни да је потребно да се ради на додатним оптимизацијама, да је читав процес поновног исцртавања компоненти веома скуп и да овде уопште нема реактивности. </p> <p> А да ли је довољно брз да задовољи захтеве већине? То сигурно да. </p> </div></div></main> <footer class=svelte-1eviz8r><div class="svelte-1eviz8r footer-content"><a class="svelte-1eviz8r copyright-link" href=/ >Трајекторија<span class="svelte-1eviz8r copy">©</span><span class="svelte-1eviz8r date">2021</span></a> <div class="svelte-1eviz8r controls"><button class=svelte-1eviz8r> <svg fill=currentColor height=14 stroke=currentColor stroke-width=0 viewBox="0 0 20 20" width=14 xmlns=http://www.w3.org/2000/svg><path d="M15 8a3 3 0 10-2.977-2.63l-4.94 2.47a3 3 0 100 4.319l4.94 2.47a3 3 0 10.895-1.789l-4.94-2.47a3.027 3.027 0 000-.74l4.94-2.47C13.456 7.68 14.19 8 15 8z"></path></svg></button> <button class=svelte-1eviz8r><svg fill=currentColor height=14 stroke=currentColor stroke-width=0 viewBox="0 0 576 512" width=14 xmlns=http://www.w3.org/2000/svg><path d="M342.8 352.7c5.7-9.6 9.2-20.7 9.2-32.7 0-35.3-28.7-64-64-64-17.2 0-32.8 6.9-44.3 17.9-16.3-29.6-47.5-49.9-83.7-49.9-53 0-96 43-96 96 0 2 .5 3.8.6 5.7C27.1 338.8 0 374.1 0 416c0 53 43 96 96 96h240c44.2 0 80-35.8 80-80 0-41.9-32.3-75.8-73.2-79.3zm222.5-54.3c-93.1 17.7-178.5-53.7-178.5-147.7 0-54.2 29-104 76.1-130.8 7.3-4.1 5.4-15.1-2.8-16.7C448.4 1.1 436.7 0 425 0 319.1 0 233.1 85.9 233.1 192c0 8.5.7 16.8 1.8 25 5.9 4.3 11.6 8.9 16.7 14.2 11.4-4.7 23.7-7.2 36.4-7.2 52.9 0 96 43.1 96 96 0 3.6-.2 7.2-.6 10.7 23.6 10.8 42.4 29.5 53.5 52.6 54.4-3.4 103.7-29.3 137.1-70.4 5.3-6.5-.5-16.1-8.7-14.5z"></path></svg></button></div></div></footer></div> 